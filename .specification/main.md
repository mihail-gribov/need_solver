Ниже — формулировка задачи (ТЗ) на реализацию **универсальной системы подбора объектов по результатам опроса**. Это обобщение нашего диалога (кошки/породы — частный случай).

---

## Задача

Реализовать систему, которая по результатам диалогового/анкетного опроса пользователя подбирает наиболее подходящий объект из заранее заданного каталога объектов (например: породы кошек/собак, модели автомобилей, направления обучения, варианты товаров и т.п.).

Система должна:

1. собирать у пользователя **потребности** и **ограничения**,
2. сопоставлять их с характеристиками объектов,
3. вычислять **оценку соответствия** и ранжировать объекты,
4. задавать **следующий вопрос адаптивно**, чтобы минимизировать число вопросов до получения устойчивого топ-набора объектов.

---

## Модель данных

### 1) Каталог объектов

Каталог состоит из объектов (O = {o_1, ..., o_n}).
Каждый объект описывается вектором базовых характеристик:

[
X^{(o)} = [x_1, x_2, ..., x_d], \quad x_i \in [0,1]
]

Где (d) — размерность базиса характеристик.

Требования к базису характеристик:

* покрывает все потребности/ограничения пользователя,
* по возможности минимален и не содержит прямых дубликатов,
* допускает как непрерывные признаки ([0,1]), так и категориальные, закодированные через one-hot группы.

### 2) Профиль пользователя

Профиль пользователя формируется по итогам опроса и состоит из двух наборов интенсивностей:

* **Потребности** (R = [r_1, ..., r_K]), (r_k \in [0,1])
* **Ограничения** (C = [c_1, ..., c_L]), (c_l \in [0,1])

Интерпретация:

* 0 — не важно/нет ограничения,
* 1 — критично/жёсткий запрет или требование.

### 3) Формулы потребностей и ограничений

Каждая потребность и каждое ограничение задаются формулой над базисом характеристик объектов.
Базовый формат: **НКФ (CNF)** — конъюнкция дизъюнкций литералов:

* литерал: (x_i) или (\neg x_i)
* клауза: (L_1 \lor ... \lor L_m)
* формула: (K_1 \land ... \land K_n)

Система должна поддерживать вычисление «степени выполнения» формулы объектом на непрерывных признаках (fuzzy-оценка), например:

* (\text{sat}(x_i)=x_i)
* (\text{sat}(\neg x_i)=1-x_i)
* (\text{sat}(\lor)=\max)
* (\text{sat}(\land)=) взвешенное среднее по клаузам, где вес клаузы зависит от размера дизъюнкции (например, (1/m)).

---

## Опросник

### 1) Структура вопросов

Система содержит набор вопросов (Q = {q_1, ..., q_M}).

Каждый вопрос имеет:

* текст,
* набор вариантов ответов,
* для каждого ответа:

  * правила обновления профиля (R) и (C) (например, установить/усилить некоторые (r_k) или (c_l)),
  * список вопросов, которые становятся нерелевантными и должны быть отключены (disabled),
  * (опционально) правила перехода/ветвления.

Правила ответа должны быть описаны декларативно (JSON/YAML), чтобы логика опроса редактировалась без изменения кода.

---

## Вычисление результата

### 1) Фильтрация по ограничениям

Система должна уметь:

* жёстко отбрасывать объекты, нарушающие сильные ограничения (например, при (c_l \ge T_hard) и sat((G_l)) ниже порога),
* либо применять штрафы (soft constraints), уменьшая итоговый скор.

### 2) Скор соответствия объекту

Для каждого объекта вычисляется:

* удовлетворение каждой потребности (s_k(o) \in [0,1]),
* удовлетворение каждого ограничения (h_l(o) \in [0,1]),
* итоговый скор:

[
Score(o) = NeedsScore(o) \cdot ConstraintsPenalty(o)
]

Где (NeedsScore) — взвешенное среднее с весами (r_k), а (ConstraintsPenalty) — штраф/фильтр по ограничениям с весами (c_l).

Система возвращает:

* ранжированный список объектов (top-N),
* объяснения: какие потребности закрыты/не закрыты и какие ограничения конфликтуют,
* (опционально) дополнительные свойства объектов, которые не участвуют в логике, но отображаются пользователю как справочная информация.

---

## Адаптивный выбор следующего вопроса

Система должна выбирать следующий вопрос динамически, опираясь на текущее состояние:

* известные значения (R, C),
* текущий пул допустимых объектов (S \subseteq O),
* ещё не заданные и не disabled вопросы.

Цель выбора вопроса: минимизировать ожидаемый размер (S) после ответа (или максимизировать information gain).
Допускается смешанная стратегия:

* в начале приоритизировать вопросы про ограничения,
* затем уточнять потребности,
* затем эстетика/тонкая настройка.

---

## Результат реализации

Нужно реализовать модуль(и), которые обеспечивают:

1. загрузку каталога объектов и их векторных профилей;
2. загрузку базиса потребностей/ограничений и формул;
3. загрузку вопросов, ответов, правил обновления профиля и disable-логики;
4. состояние сессии опроса пользователя;
5. расчёт skoring + фильтрации + объяснений;
6. выбор следующего вопроса;
7. интерфейс API (например, REST/GraphQL) или библиотечный интерфейс для интеграции в UI.

---

## Критерии качества

* минимизация числа вопросов до устойчивого топ-набора,
* интерпретируемость (объяснения, почему объект в топе/почему исключён),
* расширяемость (легко добавлять новые типы объектов и новые вопросы),
* отделение контента (каталог/вопросы/формулы) от кода.

---

Если хочешь, могу сразу оформить это как:

* JSON-schema для объектов/формул/вопросов,
* список эндпоинтов API для сервиса опроса,
* или минимальный прототип архитектуры (модули + структуры данных).
